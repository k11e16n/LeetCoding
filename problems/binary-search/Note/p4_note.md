# 4. Median of Two Sorted Arrays

## 📖 為什麼一定有解？
📌 因為我們在找的其實是「把整個數列切成左右兩半」
目標是把
👉 A 和 B 加起來的前一半
放在「左半邊」
後一半放在「右半邊」

而已排序陣列有個特性：
切割的位置總能調整，讓左半邊的最大值 ≤ 右半邊的最小值

## 📊 重點公式：
切割點 j 跟 i 的關係是：

ini
複製
編輯
j = (m + n + 1) / 2 - i
固定的，這樣就能保證：

左邊總共 (m + n + 1) / 2 個

右邊總共剩下的

## 📖 為什麼 binary search 能找到？
每次判斷

如果 B[j-1] > A[i]
→ A 左邊太少，i 往右

如果 A[i-1] > B[j]
→ A 左邊太多，i 往左

由於 i 初始範圍是 [0, m]，每次調整都縮小範圍

A、B 是排序好的 → 這兩個不等式必然有一個正確的切割點滿足兩邊大小順序

👉 而且因為是排序好的資料組合，必然存在一個切割點讓
A[i-1] ≤ B[j] 且 B[j-1] ≤ A[i]

## 📖 更嚴謹的數學性質 (背後保證)
對於兩個已排序陣列，合併成一個已排序陣列，總存在一個切割點，把兩者切成「左邊最大值 ≤ 右邊最小值」的狀態

這是「已排序資料的中位數劃分定理」
（Median Partition Property）

## 📋 總結：
條件	意義
B[j-1] > A[i]	A 左邊太少，i 往右
A[i-1] > B[j]	A 左邊太多，i 往左
其他情況	完美切割，找到中位數

因為 A、B 是排序好的，這個 binary search 過程一定會找到解

## My Note
- 注意index，我們是找切割點所以 i的min, max是0,跟m而不是m-1
- 注意保證 m<=n
	我們要保證 m <= n 是為了讓 binary search 的對象是比較短的那個陣列
	這樣才能保證：
	- binary search 的範圍小（log(min(m, n))）	
	- 避免二分時超出陣列邊界

## Q: 為什麼 j = (m + n + 1) / 2 - i?  
i : 長度為m的陣列A中的切割點  
j : 長度為n的陣列B中的切割點  
目標要找中點以符合左半邊<=右半邊。  
考慮到基數跟偶數狀況  
1. 偶數
* 數量部分：左半部分的长度等于右半部分 i + j = m - i + n - j , 也就是 j = ( m + n ) / 2 - i  
* 數值部分：左半部分最大的值小于等于右半部分最小的值 max ( A [ i - 1 ] , B [ j - 1 ]）） <= min ( A [ i ] , B [ j ]））  
那么，中位数就可以表示如下
（左半部分最大值 + 右半部分最小值 ）/ 2 。
（max ( A [ i - 1 ] , B [ j - 1 ]）+ min ( A [ i ] , B [ j ]）） / 2

2. 奇數  
* 數量部分：左半部分的长度比右半部分大 1
i + j = m - i + n - j + 1也就是 j = ( m + n + 1) / 2 - i
* 數值部分：左半部分最大的值小于等于右半部分最小的值 max ( A [ i - 1 ] , B [ j - 1 ]）） <= min ( A [ i ] , B [ j ]））
那么，中位数就是
左半部分最大值，也就是左半部比右半部分多出的那一个数。
max ( A [ i - 1 ] , B [ j - 1 ]）

綜合以上，第一個條件可以變成 j = ( m + n + 1) / 2 - i，因为如果 m + n 是偶数，由于我们取的是 int 值，**所以加 1 也不会影響结果**。

## Q: 為什麼是這樣比較  
为了保证 max ( A [ i - 1 ] , B [ j - 1 ]）） <= min ( A [ i ] , B [ j ]）），因为 A 数组和 B 数组是有序的，所以 A [ i - 1 ] <= A [ i ]，B [ i - 1 ] <= B [ i ] 这是天然的，所以我们只需要保证 B [ j - 1 ] < = A [ i ] 和 A [ i - 1 ] <= B [ j ] 所以我们分两种情况讨论：
